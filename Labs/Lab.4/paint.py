{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "4e977d95-1170-4ab0-8525-a2aa79a3af14",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Canvas:\n",
    "    def __init__(self, width, height):\n",
    "        self.width = width\n",
    "        self.height = height\n",
    "        self.data = [[' '] * width for i in range(height)]\n",
    "\n",
    "    def set_pixel(self, row, col, char='*'):\n",
    "        self.data[row][col] = char\n",
    "\n",
    "    def get_pixel(self, row, col):\n",
    "        return self.data[row][col]\n",
    "    \n",
    "    def clear_canvas(self):\n",
    "        self.data = [[' '] * self.width for i in range(self.height)]\n",
    "    \n",
    "    def v_line(self, x, y, w, **kargs):\n",
    "        for i in range(x,x+w):\n",
    "            self.set_pixel(i,y, **kargs)\n",
    "\n",
    "    def h_line(self, x, y, h, **kargs):\n",
    "        for i in range(y,y+h):\n",
    "            self.set_pixel(x,i, **kargs)\n",
    "            \n",
    "    def line(self, x1, y1, x2, y2, **kargs):\n",
    "        slope = (y2-y1) / (x2-x1)\n",
    "        for y in range(y1,y2):\n",
    "            x= int(slope * y)\n",
    "            self.set_pixel(x,y, **kargs)\n",
    "            \n",
    "    def display(self):\n",
    "        print(\"\\n\".join([\"\".join(row) for row in self.data]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "a54ac8c1-576f-4244-ba42-396c3ec7c473",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Shape2:\n",
    "    def __init__(self, x, y):\n",
    "        self._x = x\n",
    "        self._y = y\n",
    "\n",
    "    def area(self):\n",
    "        raise NotImplementedError(\"Subclasses must implement the 'area' method.\")\n",
    "\n",
    "    def perimeter(self):\n",
    "        raise NotImplementedError(\"Subclasses must implement the 'perimeter' method.\")\n",
    "\n",
    "    def get_x(self):\n",
    "        return self._x\n",
    "\n",
    "    def get_y(self):\n",
    "        return self._y\n",
    "\n",
    "    def perimeter_points(self, num_points=16):\n",
    "        raise NotImplementedError(\"Subclasses must implement the 'perimeter_points' method.\")\n",
    "\n",
    "    def is_inside(self, test_x, test_y):\n",
    "        raise NotImplementedError(\"Subclasses must implement the 'is_inside' method.\")\n",
    "\n",
    "    def overlap(self, other):\n",
    "        points1 = self.perimeter_points()\n",
    "        points2 = other.perimeter_points()\n",
    "\n",
    "        for point1 in points1:\n",
    "            if point1 in points2:\n",
    "                return True\n",
    "\n",
    "        return False\n",
    "\n",
    "\n",
    "class rectangle3(Shape2):\n",
    "    \n",
    "    def __init__(self, length, width, x, y):\n",
    "        super().__init__(x, y)\n",
    "        self._length = length\n",
    "        self._width = width\n",
    "\n",
    "    def area(self):\n",
    "        print(\"Area of this rectangle is\", self._length * self._width, \"units\")\n",
    "\n",
    "    def perimeter(self):\n",
    "        print(\"Perimeter of this rectange is\", 2*(self._length + self._width), \"units\")\n",
    "\n",
    "    def get_length(self):\n",
    "        return self._length\n",
    "\n",
    "    def get_width(self):\n",
    "        return self._width\n",
    "\n",
    "    def perimeter_points(self, num_points=16):\n",
    "        points = set()\n",
    "\n",
    "        vertices = [\n",
    "            (self._x, self._y),\n",
    "            (self._x + self._length, self._y),\n",
    "            (self._x + self._length, self._y - self._width),\n",
    "            (self._x, self._y - self._width)\n",
    "        ]\n",
    "\n",
    "        points.update(vertices)\n",
    "\n",
    "        for i in range(4):\n",
    "            start_x, start_y = vertices[i]\n",
    "            end_x, end_y = vertices[(i + 1) % 4]\n",
    "\n",
    "            for j in range(1, 3):\n",
    "                t = j / 3\n",
    "                x_coord = round((1 - t) * start_x + t * end_x)\n",
    "                y_coord = round((1 - t) * start_y + t * end_y)\n",
    "                points.add((int(x_coord), int(y_coord)))\n",
    "\n",
    "        return list(points)\n",
    "\n",
    "    def is_inside(self, test_x, test_y):\n",
    "        return self._x <= test_x <= self._x + self._length and self._y - self._width <= test_y <= self._y\n",
    "\n",
    "class circle3(Shape2):\n",
    "    def __init__(self, radius, x, y):\n",
    "        super().__init__(x, y)\n",
    "        self._radius = radius\n",
    "\n",
    "    def area(self):\n",
    "        print(\"Area of this circle is\", round(np.pi * self._radius**2, 2), \"units\")\n",
    "\n",
    "    def perimeter(self):\n",
    "        print(\"Perimeter of this circle is\", round(2 * np.pi * self._radius, 2), \"units\")\n",
    "\n",
    "    def get_radius(self):\n",
    "        return self._radius\n",
    "\n",
    "    def perimeter_points(self, num_points=16):\n",
    "        points = []\n",
    "\n",
    "        for i in range(num_points):\n",
    "            theta = 2 * np.pi * i / num_points\n",
    "            x_coord = round(self._x + self._radius * np.cos(theta), 2)\n",
    "            y_coord = round(self._y + self._radius * np.sin(theta), 2)\n",
    "            points.append((x_coord, y_coord))\n",
    "\n",
    "        return points\n",
    "\n",
    "    def is_inside(self, test_x, test_y):\n",
    "        distance_squared = (test_x - self._x)**2 + (test_y - self._y)**2\n",
    "        return distance_squared <= self._radius**2\n",
    "\n",
    "class triangle2(Shape2):\n",
    "    \n",
    "    def __init__(self, side1, side2, side3, x, y):\n",
    "        super().__init__(x, y)\n",
    "        self._side1 = side1\n",
    "        self._side2 = side2\n",
    "        self._side3 = side3\n",
    "\n",
    "    def perimeter(self):\n",
    "        print(\"Perimeter of this triangle is\", self._side1 + self._side2 + self._side3, \"units\")\n",
    "\n",
    "    def area(self):  # Using Heron's Formula\n",
    "        s = (self._side1 + self._side2 + self._side3) / 2\n",
    "        print(\"Area of this triangle is\", sqrt(s * (s - self._side1) * (s - self._side2) * (s - self._side3)), \"units\")\n",
    "\n",
    "    def get_side1(self):\n",
    "        return self._side1\n",
    "\n",
    "    def get_side2(self):\n",
    "        return self._side2\n",
    "\n",
    "    def get_side3(self):\n",
    "        return self._side3\n",
    "\n",
    "    def perimeter_points(self, num_points=16):\n",
    "        points = set()\n",
    "\n",
    "        vertices = [\n",
    "            (self._x, self._y),\n",
    "            (self._x + self._side1, self._y),\n",
    "            (self._x + self._side1 - (self._side3**2 - self._side2**2) / (2 * self._side1), self._y - sqrt(self._side3**2 - ((self._side3**2 - self._side2**2) / (2 * self._side1))**2))\n",
    "        ]\n",
    "\n",
    "        points.update(vertices)\n",
    "\n",
    "        for i in range(3):\n",
    "            start_x, start_y = vertices[i]\n",
    "            end_x, end_y = vertices[(i + 1) % 3]\n",
    "\n",
    "            for j in range(1, 5):\n",
    "                t = j / 5 \n",
    "                x_coord = round((1 - t) * start_x + t * end_x, 2)\n",
    "                y_coord = round((1 - t) * start_y + t * end_y, 2)\n",
    "                points.add((x_coord, y_coord))\n",
    "\n",
    "        return list(points)\n",
    "    \n",
    "    def is_inside(self, test_x, test_y):\n",
    "        def sign(p1, p2, p3):\n",
    "            return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n",
    "\n",
    "        d1 = sign((test_x, test_y), (self._x, self._y), (self._x + self._side1, self._y))\n",
    "        d2 = sign((test_x, test_y), (self._x + self._side1, self._y), (self._x + self._side1 - self._side3, self._y - self._side2))\n",
    "        d3 = sign((test_x, test_y), (self._x + self._side1 - self._side3, self._y - self._side2), (self._x, self._y))\n",
    "\n",
    "        has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n",
    "        has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n",
    "\n",
    "        return not (has_neg and has_pos)\n",
    "\n",
    "\n",
    "class CompoundShape(Shape2):\n",
    "    def __init__(self, shapes):\n",
    "        super().__init__(0, 0)  # Center of the compound shape is set to (0, 0)\n",
    "        self.shapes = shapes\n",
    "\n",
    "    def area(self):\n",
    "        return sum(shape.area() for shape in self.shapes)\n",
    "\n",
    "    def perimeter(self):\n",
    "        return sum(shape.perimeter() for shape in self.shapes)\n",
    "\n",
    "    def perimeter_points(self, num_points=16):\n",
    "        points = []\n",
    "        for shape in self.shapes:\n",
    "            points.extend(shape.perimeter_points(num_points))\n",
    "        return points\n",
    "\n",
    "    def is_inside(self, test_x, test_y):\n",
    "        return any(shape.is_inside(test_x, test_y) for shape in self.shapes)\n",
    "\n",
    "    def overlap(self, other):\n",
    "        return any(shape.overlap(other) for shape in self.shapes)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "43ce9373-44d6-4aea-b9c4-2a2964aa5ee8",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
